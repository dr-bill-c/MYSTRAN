# USE_Interface_statements.perl
# -----------------------------

# Begin license text.                                                                                    
# _______________________________________________________________________________________________________
                                                                                                         
# Copyright 2019 Dr William R Case, Jr (dbcase29@gmail.com)                                              
                                                                                                         
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and      
# associated documentation files (the "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to   
# the following conditions:                                                                              
                                                                                                         
# The above copyright notice and this permission notice shall be included in all copies or substantial   
# portions of the Software.                                                                              
                                                                                                         
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS                                
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                            
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                            
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                                 
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                          
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN                              
# THE SOFTWARE.                                                                                          
# _______________________________________________________________________________________________________
                                                                                                        
# End license text.                                                                                      

# This perl script is part of a process to generate and compile modules that contain USE_xxxxxx_Interface statements for MYSTRAN
# subroutines. It is intended to replace the error prone manual entering of USE Interface statements for each subroutine which
# are needed to insure that all CALL statements have the proper number and type of arguments. The description below describes the
# process, of which this perl script is a part (see (1) below):

# At the DOS prompt in the dir where the USE modules are to go (assuming all of the batch files below are in the current path):

#                   (1) Run USE1.BAT which executes this perl script to create the fortran modules with
#                       the USE_xxxxxx_Interface code for all of the MYSTRAN subrs. USE_Interface_statements.perl scans MYSTRAN
#                       subroutines to find CALL statements and creates modules named subr-name_USE_IFs.f90 (where subr-name is
#                       the name of the MYSTRAN subroutine for which the interface statements are generated). A typical module 
#                       generated by USE_Interface_statements.perl is (for MYSTRAN subr READ_INI.f90 is:

#                             MODULE READ_INI_USE_IFs

#                             USE OPNERR_Interface
#                             USE OUTA_HERE_Interface
#                             USE MKJCARD_Interface
#                             USE WRITE_FILNAM_Interface
#                             USE SET_FILE_CLOSE_STAT_Interface

#                             END MODULE READ_INI_USE_IFs

#                       This module contains USE_xxxxxx_Interface statements for all of the unique CALL statements in MYSTRAN
#                       subr READ_INI that are not CONTAINd in READ_INI (since interfaces for CONTAINd subrs are automatically
#                       checked). Then, in subr READ_INI, a statement USE READ_INI_USE_IFs is included to use this module.
#                       This way, we can automatically have USE_xxxxxx_Interface statements in MYSTRAN subrs without having
#                       to enter tham manually (error prone - may miss some interface statements if we do it manually).

#                   (2) Run USE2.BAT %1 (where %1 = D for debug code or C for production code) which executes 
#                       Generate_USE2_Compile_file-BAT.perl perl script to generate a batch file called USE_Compile_file.BAT

#                   (3) Run USE_Compile_file.BAT %1 %2 (where %1 = deb or prod and %2 = D or C) which executes perl script
#                       BAT_compile_file.perl to generate a batch file called Compile_USE.BAT. (Note: BAT_compile_file.perl
#                       is the perl script that is also used to generate batch files to compile MYSTRAN subroutines)

#                   (4) Make sure you are in the USE_Ifs directory (e.g. \MYSTRAN\USE_Interfaces)
#                       and run Compile_USE.BAT %1 (where %1 = D or C) to compile all of the modules that contain the
#                       USE xxxxxx_Interface statements for MYSTRAN subroutines

# All 4 steps have to be run initially. Thereafter, steps 1 and 4 should be run to update the module code whenever MYSTRAN subrs
# are modified (e.g. when  calls to new subrs are added or when some are dropped)

# Copyright (c) 2003 Bill Case.

# Change log:

# **********************************************************************************************************************************
$program_name                 = $0;
$num_args                     = 0;
$num_files                    = @ARGV - $num_args;
$file_count                   = 1;

do
{
   $filename[$file_count] = $ARGV[$file_count+$num_args-1];
   $file_count++;
}  until ($file_count > $num_files);                       # Need $file_count > $num_files since $file_count is incremented after last file read

$file_count = 1;
while ($file_count <=$num_files)
{
   unless (open(INFILE,$filename[$file_count]))            # Open one of the files
   {
      if (-e $filename[$file_count])
      {
         die ("File $filename[$file_count] exists, but cannot be opened.\n");
      }
      else
      {
         die ("File $filename[$file_count] does NOT exist.\n");
      }
   }
DL:   $line = <INFILE>;
      
#print ("! ARGV = ", @ARGV, "\n");

      if ($line =~ /Begin MIT license text/)               # Write out license text
      {
         print ($line);
         $line = <INFILE>;
         until ($line =~ /End MIT license text/)
         {
            print ($line);
            $line = <INFILE>;
         }
         print ($line);
         $line = <INFILE>;
#        exit $line;
         print ("\n");
         goto EL;
      }
      else
      {
         goto DL;
      }

EL:$num_CONTAINd_subrs = 0;                                # The following code (down to CL:) gets any subr names that are CONTAIN'd
AL:$line = <INFILE>;                                       # so that we can ignore these (their names won't go into the modules)       
   chop ($line);    
   if ($line =~ /^ *CONTAINS/i)
   {
BL:   $line = <INFILE>;
      chop ($line);
      if ($line =~ /^ *SUBROUTINE/i)
      {
         @words = split (/[\( ]+/,$line);
         $num_CONTAINd_subrs = $num_CONTAINd_subrs +1;
         $CONTAINd_subr_names[$num_CONTAINd_subrs] = $words[2];
         goto BL;
      }
      else
      {
         if (eof)
         {
            goto CL;
         }
         else
         {
            goto BL;
         }
      }
   }
   else
   {
      if (eof)
      {
         goto CL;
      }
      else
      {
         goto AL;
      }
   }
CL:close (INFILE);

   $num_subrs_called = 0;                                  # Following code gets all CALL statements in $filename (but ignores
   unless (open(INFILE,$filename[$file_count]))            # repetitive names and ones in $CONTAINd_subr_names, above)
   {
      if (-e $filename[$file_count])
      {
         die ("File $filename[$file_count] exists, but cannot be opened.\n");
      }
      else
      {
         die ("File $filename[$file_count] does not exist.\n");
      }
   }

NL:$line = <INFILE>;
   if ($line ne "")
   {
      chop ($line);
      if ($line =~ /^ *PROGRAM|^ *SUBROUTINE/i)
      {
         @words = split (/[\( ]+/,$line);
         
         $position = index($line," ");
#        printf ("%s %s","position = ",$position, "\n");          print ("\n");

         if ($position == 0)
         {
            @words = split (/[\t (]+/,$line);
            $procedure_type = $words[1];
            if ($words[2] =~ /[a-zA-Z][_0-9a-zA-Z]*\n/)
            {
               chop $words[2];
            }
               $parent_subr_name = $words[2];
         }
         elsif ($position > 0)
         {
            @words = split (/[\t (]+/,$line);
            $procedure_type = $words[0];
            if ($words[1] =~ /[a-zA-Z][_0-9a-zA-Z]*\n/)
            {
               chop $words[1];
            }
               $parent_subr_name = $words[1];
         }

#        printf ("%s %s", "procedure_type   = ",$procedure_type)  ; print ("\n");
#        printf ("%s %s", "parent_subr_name = ",$parent_subr_name); print ("\n");
         
         print ("      MODULE ",$parent_subr_name,"_USE_IFs","\n");
         print("\n");
         print("! USE Interface statements for all subroutines called by ",$procedure_type," ",$parent_subr_name,"\n");

NL2:     $line = <INFILE>;
         if ($line ne "")
         {
            chop ($line);
                                                           # Skip any lines that have the following text
            if ($line =~ /LAPACK SUBR XERBLA SHOULD HAVE REPORTED AN ERROR ON AN ILLEGAL ARGUMENT IN A CALL TO LAPACK SUBR/i)
            {
               goto NL2;
            }
                                                           # Initially, take all lines that have CALL (any case)
#           if ($line =~ / *CALL +[\_0-9a-zA-Z]+ *\(*/i)
            if ($line =~ / * CALL +/i)
            {
               @words = split (/ * CALL +/i,$line);
                                                           # Exclude CALL (any case) if line begins with ! or line is FORMAT 
               if (($words[0] =~ /\!/) || ($words[0] =~ /FORMAT/i))
               {
                  goto NL2;
               }

               $num_subrs_called++;
               @words2 = split(/[\( ]+/,$words[1]);
               $called_subr_names[$num_subrs_called] = $words2[0];
               goto NL2
            }
            else
            {
            goto NL2;
            }
         }
      }
      else 
      {
         goto NL
      }

      if ($num_subrs_called > 0)
      {
         print("\n");

         $j = 1;
         $new_name = "yes";
         while($j <= $num_subrs_called)
         {
            $k = 1;
            $new_name = "yes";
            while($k < $j)
            {
               $lc_called_subr_names_k = lc($called_subr_names[$k]);
               $uc_called_subr_names_k = uc($called_subr_names[$k]);
               $called_subr_names_k    = $called_subr_names[$k];
               if (($called_subr_names[$j] eq $lc_called_subr_names_k) || ($called_subr_names[$j] eq $uc_called_subr_names_k) || ($called_subr_names[$j] eq $called_subr_names_k))
               {
                  $new_name = "no";
               }
#######        printf ("%-28s %-35s",$called_subr_names[$j], $new_name, "\n");
#######        print  ("\n");
               $k++;
            }
            if ($new_name eq "yes")
            {
               $i = 1;
               do
               {
                  $lc_CONTAINd_subr_names_i = lc($CONTAINd_subr_names[$i]);    
                  $uc_CONTAINd_subr_names_i = uc($CONTAINd_subr_names[$i]);
                  $CONTAINd_subr_names_i = $CONTAINd_subr_names[$i];
                  if (($called_subr_names[$j] eq $lc_CONTAINd_subr_names_i) || ($called_subr_names[$j] eq $uc_CONTAINd_subr_names_i) || ($called_subr_names[$j] eq $CONTAINd_subr_names_i))
                  {
                     $new_name = "no";
                  }
                  $i++;
               }
               until ($i > $num_CONTAINd_subrs);
               if ($new_name eq "yes")
               {
                  if(($called_subr_names[$j] ne "GETENV"  ) && ($called_subr_names[$j] ne "GETCL"          ) && 
                     ($called_subr_names[$j] ne "BANDIT"  ) && ($called_subr_names[$j] ne "DATE_AND_TIME"  ) &&
                     ($called_subr_names[$j] ne "DSYEV"   ) && ($called_subr_names[$j] ne "DGEMM"          ) && 
                     ($called_subr_names[$j] ne "DGETRF"  ) && ($called_subr_names[$j] ne "DGETRS"         ) && 
                     ($called_subr_names[$j] ne "dgetrf"  ) && ($called_subr_names[$j] ne "dgetri"         ) && 
                     ($called_subr_names[$j] ne "DPBTRF"  ) && ($called_subr_names[$j] ne "DPBTRS"         ) && 
                     ($called_subr_names[$j] ne "DSBAND"  ) && ($called_subr_names[$j] ne "DSBGVX_GIV_MGIV") && 
                     ($called_subr_names[$j] ne "DPBCON"  ) && ($called_subr_names[$j] ne "DPBEQU"         ) && 
                     ($called_subr_names[$j] ne "DLAQSB"  ) && ($called_subr_names[$j] ne "DSBMV"          ) &&
                     ($called_subr_names[$j] ne "DPOTRF"  ) && ($called_subr_names[$j] ne "DPOTRI"         ) &&
                     ($called_subr_names[$j] ne "CPU_TIME") &&
                     ($called_subr_names[$j] ne "STARTUP" ) && ($called_subr_names[$j] ne "INCLUD"         ) &&
                     ($called_subr_names[$j] ne "REGCF"   ) && ($called_subr_names[$j] ne "SING"           ) &&

                     ($called_subr_names[$j] ne "DSBTRD"  ) && ($called_subr_names[$j] ne "DPTTRF_MYSTRAN" ) &&
                     ($called_subr_names[$j] ne "DGBTRF"  ) && ($called_subr_names[$j] ne "DSYTF2"         ) &&
                     ($called_subr_names[$j] ne "dtptri"  )                                                  &&

                     ($called_subr_names[$j] ne "mkl_cvt_to_null_terminated_str")                            &&
                     ($called_subr_names[$j] ne "MKL_CVT_TO_NULL_TERMINATED_STR")                            &&

                     ($called_subr_names[$j] ne "TOLSET"  ) && ($called_subr_names[$j] ne "System_clock"   ) &&
                     
                     ($called_subr_names[$j] ne "trl_g_sum")                                                 &&  
                     ($called_subr_names[$j] ne "trl_init_info")                                             &&  
                     ($called_subr_names[$j] ne "trl_print_info")                                            &&  
                     ($called_subr_names[$j] ne "trl_set_iguess")                                            &&  
                     ($called_subr_names[$j] ne "trl_set_debug")                                             &&
                     ($called_subr_names[$j] ne "trl_set_checkpoint")                                        &&  
                     ($called_subr_names[$j] ne "trl_time_stamp")                                            &&  
                     ($called_subr_names[$j] ne "trlan"))

                  {
                     $num_USE_Interface_statements++;      # These are the USE xxxxxx_Interface statements that go into the module
                     $USE_Interface_statements[$num_USE_Interface_statements] = "      USE " . $called_subr_names[$j] . "_Interface";
                  }
               }
            }
            $j++;
         }

         $i = 1;
         while($i <= $num_USE_Interface_statements)
         {
            print("$USE_Interface_statements[$i]","\n");
            $i++;
         }
      }
      else
      {
         print("! No subrs CALL'd by ",$procedure_type," ",$parent_subr_name,"\n");
      }

      print("\n");
      print ("      END MODULE ",$parent_subr_name,"_USE_IFs","\n");

      if ($num_files > 1)
      {
         print("\n");
         print("! **********************************************************************************************************************************","\n");
      }
   }
NF:$file_count++;

}   

exit 0;
